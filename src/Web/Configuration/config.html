<div id="folderCollectionsConfigPage"
     data-role="page"
     class="page type-interior pluginConfigurationPage"
     data-require="emby-button,emby-checkbox,emby-input">

  <div class="content-primary">
    <h1>Folder Collections – Einstellungen</h1>

    <form id="fcForm" class="emby-form" onsubmit="return window.FolderCollections.save(event)">
      <div class="checkboxContainer">
        <label class="emby-checkbox-label">
          <input id="includeMovies" type="checkbox" is="emby-checkbox" />
          <span>Filme berücksichtigen</span>
        </label>
      </div>

      <div class="checkboxContainer">
        <label class="emby-checkbox-label">
          <input id="includeSeries" type="checkbox" is="emby-checkbox" />
          <span>Serien berücksichtigen</span>
        </label>
      </div>

      <div class="inputContainer">
        <label class="emby-input-label" for="minItems">Mindestanzahl Items</label>
        <input id="minItems" is="emby-input" type="number" min="0" step="1" />
        <div class="fieldDescription">Nur wenn mindestens so viele Items gefunden werden, wird eine Sammlung erstellt/aktualisiert.</div>
      </div>

      <div class="inputContainer">
        <label class="emby-input-label" for="prefix">Prefix</label>
        <input id="prefix" is="emby-input" type="text" />
      </div>

      <div class="inputContainer">
        <label class="emby-input-label" for="suffix">Suffix</label>
        <input id="suffix" is="emby-input" type="text" />
      </div>

      <div class="inputContainer">
        <label class="emby-input-label">Scan-Uhrzeit</label>
        <div style="display:flex; gap:.5rem; align-items:center">
          <input id="scanHour" is="emby-input" type="number" min="0" max="23" style="width:90px" />
          :
          <input id="scanMinute" is="emby-input" type="number" min="0" max="59" style="width:90px" />
        </div>
      </div>

      <div class="inputContainer">
        <label class="emby-input-label" for="pathPrefixes">Wurzelpfade (je Zeile)</label>
        <textarea id="pathPrefixes" rows="5" is="emby-input" style="width:100%"></textarea>
      </div>

      <div class="inputContainer">
        <label class="emby-input-label" for="ignorePatterns">Ignore-Muster (je Zeile)</label>
        <textarea id="ignorePatterns" rows="4" is="emby-input" style="width:100%"></textarea>
        <div class="fieldDescription">Wildcards (*, ?) – oder Regex mit Präfix <code>re:</code></div>
      </div>

      <div class="checkboxContainer">
        <label class="emby-checkbox-label">
          <input id="useBasename" type="checkbox" is="emby-checkbox" />
          <span>Basename als Sammlungsname verwenden</span>
        </label>
        <div class="fieldDescription">Wenn aktiv: letzter Ordnername; sonst kompletter Pfad.</div>
      </div>

      <div class="formButtons">
        <button id="fcManualScan" is="emby-button" type="button" class="raised button-submit"
                onclick="window.FolderCollections.manualScan(this)">Manuellen Scan starten</button>
        <button is="emby-button" type="submit" class="raised button-submit">Speichern</button>
        <button id="fcCancel" is="emby-button" type="button" class="raised button-cancel"
                onclick="history.back()">Abbrechen</button>
      </div>
    </form>
  </div>
</div>

<script>
(() => {
  const pluginId = "9f4f2c47-b3c5-4b13-9b1f-1c9a5c3b8d6a";
  const $ = (id) => document.getElementById(id);
  const toLines = (arr) => Array.isArray(arr) ? arr.join("\\n") : (arr || "");
  const fromLines = (text) => (text || "").split("\\n").map(s => s.trim()).filter(Boolean);

  function buildErrorMessage(err) {
    try {
      if (err == null) return "Unbekannter Fehler";
      if (typeof err === "string") return err;
      const status     = typeof err.status !== "undefined" ? err.status : null;
      const statusText = typeof err.statusText === "string" ? err.statusText : "";
      const message    = typeof err.message === "string" ? err.message : "";
      if (status || statusText) {
        const head = status ? `HTTP ${status}${statusText ? " " : ""}${statusText}` : statusText;
        return message ? `${head} – ${message}` : head;
      }
      if (message) return message;
      return JSON.stringify(err);
    } catch { return "Unbekannter Fehler"; }
  }
  async function safeReadBody(resp) {
    try {
      if (!resp || typeof resp.text !== "function") return "";
      const t = await resp.text();
      return (t || "").slice(0, 200);
    } catch { return ""; }
  }

  async function load() {
    const cfg = await ApiClient.getPluginConfiguration(pluginId);

    $("includeMovies").checked = !!cfg.IncludeMovies;
    $("includeSeries").checked = !!cfg.IncludeSeries;
    $("minItems").value  = cfg.MinItems  ?? 2;
    $("prefix").value    = cfg.Prefix    ?? "";
    $("suffix").value    = cfg.Suffix    ?? "";
    $("scanHour").value  = cfg.ScanHour  ?? 4;
    $("scanMinute").value= cfg.ScanMinute?? 0;
    $("pathPrefixes").value  = toLines(cfg.PathPrefixes);
    $("ignorePatterns").value= toLines(cfg.IgnorePatterns);
    $("useBasename").checked = !!cfg.UseBasenameAsCollectionName;
  }

  async function saveImpl() {
    const cfg = await ApiClient.getPluginConfiguration(pluginId);

    cfg.IncludeMovies = $("includeMovies").checked;
    cfg.IncludeSeries = $("includeSeries").checked;
    cfg.MinItems = parseInt($("minItems").value, 10) || 0;
    cfg.Prefix   = $("prefix").value.trim();
    cfg.Suffix   = $("suffix").value.trim();

    const hour   = Math.min(23, Math.max(0, parseInt($("scanHour").value, 10)   || 4));
    const minute = Math.min(59, Math.max(0, parseInt($("scanMinute").value, 10) || 0));
    cfg.ScanHour   = hour;
    cfg.ScanMinute = minute;

    cfg.PathPrefixes   = fromLines($("pathPrefixes").value);
    cfg.IgnorePatterns = fromLines($("ignorePatterns").value);
    cfg.UseBasenameAsCollectionName = !!$("useBasename").checked;

    const result = await ApiClient.updatePluginConfiguration(pluginId, cfg);
    Dashboard.processPluginConfigurationUpdateResult(result);

    const verify = await ApiClient.getPluginConfiguration(pluginId);
    const want = !!$("useBasename").checked;
    const got  = !!verify.UseBasenameAsCollectionName;

    if (result?.IsUpdated === false) {
      Dashboard.alert("Konfiguration konnte nicht gespeichert werden.");
    } else if (want !== got) {
      Dashboard.alert("Hinweis: 'Basename als Sammlungsname' wurde serverseitig nicht übernommen. Prüfe PluginConfiguration.");
      console.warn("Roundtrip mismatch: wanted", want, "got", got, verify);
    } else {
      Dashboard.alert("Gespeichert.");
    }
  }

  async function manualScanImpl(btn) {
    btn?.setAttribute("disabled", "disabled");
    btn?.classList.add("idleProcessing");
    try {
      const tasks = await ApiClient.getJSON(ApiClient.getUrl("ScheduledTasks"));
      const t = tasks.find(x =>
        x?.Key === "FolderCollections.DailyScan" ||
        (typeof x?.Name === "string" && x.Name.toLowerCase().includes("folder collections"))
      );
      if (!t?.Id) throw new Error("FolderCollections-Task nicht gefunden.");

      let resp = await ApiClient.fetchApi(`/ScheduledTasks/${t.Id}/Trigger`, { method: "POST" });
      if (!resp?.ok) {
        resp = await ApiClient.fetchApi(`/ScheduledTasks/Running/${t.Id}`, { method: "POST" });
        if (!resp?.ok) {
          const txt = await safeReadBody(resp);
          throw new Error(`${resp?.status || ""} ${resp?.statusText || ""} ${txt}`.trim());
        }
      }
      Dashboard.alert("Manueller Scan gestartet!");
    } finally {
      btn?.removeAttribute("disabled");
      btn?.classList.remove("idleProcessing");
    }
  }

  // Global verfügbar machen, damit onclick/onsubmit IMMER greifen
  window.FolderCollections = {
    async save(ev) {
      try { ev?.preventDefault?.(); await saveImpl(); }
      catch (err) { Dashboard.alert("Speichern fehlgeschlagen: " + buildErrorMessage(err)); console.error(err); }
      return false;
    },
    async manualScan(btn) {
      try { await manualScanImpl(btn); }
      catch (err) { Dashboard.alert("Fehler beim Starten des Scans: " + buildErrorMessage(err)); console.error(err); }
    }
  };

  // zusätzlich versuchen wir automatisch zu laden
  const tryInit = () => load().catch(err => { Dashboard.alert("Konfiguration konnte nicht geladen werden: " + buildErrorMessage(err)); console.error(err); });
  document.addEventListener("DOMContentLoaded", tryInit);
  document.addEventListener("viewshow", tryInit);
  document.addEventListener("pageshow", tryInit);
})();
</script>
